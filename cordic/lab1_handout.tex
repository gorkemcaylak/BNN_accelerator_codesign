%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=letter, fontsize=11.6pt]{scrartcl} % A4 paper and 11pt font size

%\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
%\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage[hmargin=2.5cm,vmargin=2.5cm]{geometry}

%\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

\usepackage{sectsty} % Allows customizing section commands
%\allsectionsfont{\centering \normalfont\scshape}
\allsectionsfont{\normalsize} 
 % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{12pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength{\parskip}{3pt}
\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\usepackage{xcolor}
\newcommand{\fixme}[1]{\textcolor{red}{\small [~#1~]}}

\sloppy

\title{	
\normalfont \normalsize 
\textsc{ECE5775 High-Level Digital Design Automation, Fall 2017} \\  
School of Electrical Computer Engineering, Cornell University \\ [11pt]% Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\large Lab 1: CORDIC Design \\ % The assignment title
\small Due Friday, September 8, 2017, 11:59pm
\horrule{0.5pt} \\[0.5cm] % Thick bottom horizontal rule
\vspace{-15ex}}

%\author{Zhiru Zhang} % Your name
%\date{\normalsize\today} % Today's date or a custom date
\date{}

\begin{document}

\maketitle % Print the title
%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------
\section{Introduction}

\textbf{CO}ordinate \textbf{R}otation \textbf{D}Igital \textbf{C}omputer (CORDIC) is a method for calculating a variety of functions including trigonometric and hyperbolic. The various functions are calculated through an iterative set of vector rotations. At the end of these rotations, the value of the function is easily determined from the (x, y) coordinate. A CORDIC is often used to achieve low-cost multiplierless sine/cosine implementations in FPGA as well as ASIC designs. To obtain a good understanding of CORDIC for the purpose of this lab, \textbf{please read Chapter 15 of \textit{A Practical Introduction to Hardware/Software Codesign} \cite{cordic}}.

\section{Materials}
You are given a zip file named  
$lab1.zip$ on the ecelinux server, which contains the following files for you to build the project.
\begin{itemize}

\item \textbf{cordic}:
  \begin{itemize}
  \item \textbf{kernel}:contains the actual kernel file.
    \begin{itemize}
    \item \texttt{cnn.cpp}: \textbf{an incomplete} file that defines the kernel function cordic.
    \end{itemize}
  \item \textbf{host}:contains all the codes for host.
     \begin{itemize}
     \item $cordic.h$: the header file with various macro and type definitions that may be useful for developing your code.
\item $check\_result.cpp$: a test bench that helps verify your code.
\item $check\_result.h$: a header file of check\_result.cpp.
\item $utils.cpp$: some utility functions sued to parse command line arguments.
\item $utils.h$: a header file of utils.cpp.
\item $typedefs.h$: a header file that defines the target device for the host.
\item $Makefile$: a makefile to compile the this application using double data type.
\item $fixed\_type.mk$: a makefile to compile the this application using fixed point data type.
\item $run\_float.sh$: this script runs the emulation using double data type.
\item $run\_fixed.sh$: this script runs the emulation using fixed point data type.
    \end{itemize}
  \end{itemize}
\item \textbf{harness}: contains the wrapper code of OpenCL APIs and a top-level makefile. Students are \textbf{not required} to understand the content of this directory.
\end{itemize}

Before starting your assignment, please \textbf{copy and unzip the zip file to your home directory}. Please be sure to \textbf{source the setup script }using the following command before compiling your source code: \texttt{export XILINXD\_LICENSE\_FILE=2100@flex.ece.cornell.edu} and \texttt{source /opt/xilinx/Xilinx\_SDx\_2017.1\_sdx\_0623\_1/SDx/2017.1/settings64.sh}. If you run into problem while doing this, and you are using a fairly new laptop, try run the following commands: \texttt{export LC\_CTYPE=en\_US.UTF-8} and \texttt{export LC\_ALL=en\_US.UTF-8}, and then restart sourcing the setup scrip.

You are encouraged to check out the Vivado HLS user guide \cite{guide} for more detailed descriptions of the Vivado HLS synthesis flow.

\section{Goal}
The goal of this assignment is to create and optimize a CORDIC core  that calculates the sine and cosine values of a given input angle. You will write the code in C++ for the CORDIC core, perform design space exploration using Vivado HLS, and explore trade-offs between area, performance, and accuracy.

The first part of this assignment is to write a functional CORDIC core using the double-precision floating-point type. With this baseline design, you will explore the design trade-offs by varying the iteration count of the main computation loop.
Since CORDIC is an iterative algorithm, the number of iterations will affect the output accuracy as well as the performance of the synthesized hardware.

The second part is to use the fixed-point data type to optimize the CORDIC core for area, performance, and accuracy. The primary design space exploration goal is to understand how the bitwidth setting affects accuracy, as well as area and performance. 

The third part asks you to maximize the throughput of the CORDIC core using optimization pragmas in Vivado HLS. This exercise will help you familiarize with common HLS optimizations and understand the effect of each optimization on the microarchitecture, performance, area, and timing of the design.

You will create a report describing the various trade-offs that you would make and how you maximize the throughput of the CORDIC core. For each design point (or architecture) you should provide its results including the area in terms of \textbf{resource utilization} (number of BRAMs, DSP48s, LUTs, and FFs), and performance in \textbf{throughput} in terms of number of CORDIC operations / second (i.e., number of input angles processed / second). The throughput can be calculated based on the reported interval (in clock cycles) and the target clock period (fixed to 10$ns$ in this assignment). 

\section{Guidelines and Hints}

\subsection{Coding and Debugging}
\begin{itemize}
	\item The input arguments to the $cordic$ function are typed $theta\_type$ 
	and $cos\_sin\_type$. These are currently set as double-precision floating-point type (i.e., $double$)\footnote{You can either use a floating-point division \texttt{x/(double)(1ULL<<SHIFT\_AMOUNT)} to perform a right shift on variable $x$ of type $double$, or create a $for$ loop to realize the shift in an iterative fashion \texttt{for (int i=0; i<SHIFT\_AMOUNT; i++) \{x=x*0.5;\}}.}. In the second part of this assignment, \textbf{you are expected to change them to a fixed-point type to optimize your design.} Please carefully consider the number of integer bits necessary for representing the range of required values. Your fixed-point design should be free of multiplication and division.

    \item Enter \texttt{source run\_float.sh} under the project folder to compile and execute the floating-point program; Enter \texttt{source run\_fixed.sh} to run the fixed-point implementation (where the $FIXED\_TYPE$ macro is defined).

	\item The test bench creates an $out.dat$ file which is useful for debugging \footnote{You are welcome to use $gdb$ as well.}. This file lists the golden sine/cosine values from $math.h$, the sine/cosine values computed from your function, and the normalized difference (error). You will be able to assess the correctness and/or accuracy of your code based on the error reported by the test bench. Note that the errors are expected to be close to but NOT exactly zero even with the correct code. The accuracy should be improved by increasing the number of iterations. Otherwise, your code is not working.
	
	%\item $run.tcl$ file adds the $-DBIT\_ACCURATE$ flag to define the $BIT\_ACCURATE$ macro for synthesis. Therefore, when you use bit-accurate fixed-point data types (i.e., $ap\_fixed$), you also need to define this macro in $cordic.h$ or in $Makefile$ when you run functional simulation.

	\item There is a constant array called $cordic\_ctab$ in $cordic.h$. You may find this useful although you do not necessarily have to use it.

	\item Please include meaningful comments in your code.
\end{itemize}

\subsection{Design Exploration}
   \begin{itemize}
   	
	\item In this assignment, you will use a fixed 10ns clock period targeting a specific Xilinx FPGA device. Clock period and target device have been specified in the $makefile$.

\item The number of iterations in your $cordic$ function will play an important role in the accuracy and performance of the design. You should explore this aspect with your floating-point design. You are encouraged to specify the iteration count in $run\_float.sh$ to run  simulation. \textbf{You can get the  important stats (i.e., accuracy, performance, and resource usage) from the Vivado HLS report $system\_estimate.xtxt$ file under the folder.} 

	\item The data types of the variables in your $cordic$ function would also make a significant difference in area, accuracy, and performance. This should be another form of your design space exploration. \textbf{For this part, the number of iterations is fixed to 20.} You should experiment extensively with the data types and your report should show how different data types affect the accuracy as well as area and performance. You are encouraged to specify the bitwidth
    settings in $cordic.h$ to run simulation and synthesis. Similar to $run\_float.sh$, the script will also automatically generate important stats in the Vivado HLS reports $system\_estimate.xtxt$ file under the folder.

    \item In addition to adjusting the bitwidth of the fixed-point type, you should also experiment with the signedness of the data type (i.e., signed $ap\_fixed$ vs. unsigned $ap\_ufixed$) and try to explain the results you obtained.  

    %\item You may also consider doing joint exploration with data precision and iteration count. For instance, you can vary the iteration count for a specific fixed point type (or vice versa) and observe the associated design trade-offs.

    \item Although synthesis takes some time to initialize after the $run$ $run_float.sh$ command, it should finish within several minutes for each design point based on our past experience. It is not normal if Vivado HLS runs for more than 10 minutes. You can use the $top$ command to check the real-time system usage to see if $ecelinux$ is overloaded with other processes.

	%\item Optimization directives such as pipelining and unrolling (including partial unrolling) would also generate different design points with interesting performance/area trade-offs. You are encouraged to explore this direction as well.

	%\item Code restructuring at C level (such as reducing the conditionals that potentially limit the parallelism) may also lead to more optimized implementations.
	\end{itemize}

\subsection{Performance Optimization}
	\begin{itemize}
		
	\item In this section, we use a design with 20 iterations and 32-bit signed fixed-point type with 8 integer bits. \textbf{We fix the configuration in this part for convenience only. This configuration may not be most area-efficient.} The goal is to maximize the throughput of this design using optimization pragmas provided by Vivado HLS, you may use array partition, pipeline and unroll,  \textbf{You are strongly encouraged to carefully study sections relevant to these pragmas} and modify the C++ source code to synthesize different microarchitectures.
	
	\item For this part of the lab, \textbf{please maximize the throughput of the CORDIC core using a minimum number of the optimization pragmas}.
		
	\end{itemize}
	
\subsection{Report}
   \begin{itemize}
   	\item Please write your report in a \textbf{single-column and single-space format with a 10pt font size. Page limit is 3, including necessary figures and tables.} 

	\item The report should start with an overview of the document. This should inform the reader what the report is about, and highlight the major results. In other words, this is similar to an abstract in a technical document. 
	Likewise there should be a summary, describing the results, and highlight the important points.

	\item There should be a section comparing and contrasting the various design points that you generated. \textbf{It is important to summarize the results of these design points in a table that clearly lists the design choices, resulting performance, area/resource allocation, and accuracy. It is also important to plot %\footnote{Consider bar graph vs. line graph, or Log vs. linear scale on the axis.} 
the results to demonstrate interesting observations and tradeoffs.\footnote{For example, error vs. number of iterations. Consider bar graph vs. line graph, or Log vs. linear scale on the axis.}} Please avoid plotting a lot of random data without providing insights.\footnote{If it is difficult to explain, then you should rethink about what you are presenting, i.e., organize the data in a different way.} 
%We recommend including at least 5 design points per \fixme{solution (listed in section \ref{deliverables})} to clearly demonstrate the trade-offs involved.
	
%	\item The document should be written in complete sentences - no fragments or just a bunch of bullet points (some bullet points are fine, but this should not be the entire document).
	\item There should be a section describing how you maximize the throughput of the design. \textbf{It is important to compare the quality of results of your synthesized design with and without optimization pragmas in terms of performance and area.} A table will likewise be helpful in this case. Explain why you add each pragma. Be sure to discuss key metrics such as target partition factor, achieved partition factor, target initiation interval, achieved initiation interval, target unroll factor, and achieved unroll factor.  Provide a conceptual comparison of the execution behavior and microarchitecture for the design with and without the optimization pragmas.

	\item All of the figures and tables should have captions. These captions should do their best to  explain the figure (explain axis, units, etc.). Ideally you can understand the report just by looking at the figures and captions. But please avoid just putting some results and never saying anything about them.

	\item Showing small code snippets to demonstrate the restructuring is fine, but please avoid listing every single line of the code.
	It is possible to be succinct and thorough at the same time.

	\item The report should only show screenshots from the tool when they demonstrate some significant idea. If you do use screenshots, make sure they are readable (e.g., not blurry). In general, you are expected to create your own figures. While more time consuming, it allows you to show the exact results, figures, and ideas you wish to present.

%	\item Please think about the best way to plot the results. For example, bar graph vs. line graph, or Log vs. linear scale on the axis.Please avoid plotting a lot of random data without providing insights. (Hint: if it is hard to explain, then you should rethink about what you are presenting, i.e., organize the data in a different way.)
\end{itemize}

\section{Deliverables}
\label{deliverables}
\textbf{Please submit your assignment on CMS.} You are expected to submit your report and your code and scripts in a single zipped file named \textbf{$cordic.zip$} that contains the following contents:
\begin{itemize}
	\item $report.pdf$: the project report in pdf.
	\item A folder named $solution$: the set of source files and scripts required to reproduce your experiments.
	Note that only these files should be submitted. Please run \texttt{make clean} to remove all the automatically generated output files.
	%\item Folder $solution\_fixed$: the source files for the fixed-point data type exploration (using $ap\_fixed$). Your design should allow you to easily explore different widths of the fractional bits (i.e. precision) while keeping the iteration count fixed to 20.
	%\item (Optional) More solutions that you may wish to show.
\end{itemize}

%Each folder should have the necessary files to synthesize and test the code, e.g., $cordic\_test.cpp$, $cordic.cpp$, $cordic.h$, $run.tcl$, etc.
%Your code should include everything so that it can be directly synthesized with Vivado HLS in the command line mode. This means that you should either use pragmas in your code or include the Tcl script with the optimization directives. 

%Note that you only need to include one solution for the design exploration on iterations and one solution for the experiments on data types. There is no need to duplicate source files for every different data type or iteration count you would have tried. However, it should be obvious from your report how you vary these parameters and obtain the set of interesting design points. 

%You are also allowed to provide one single set of source files but multiple Tcl scripts where different macros are defined for synthesis to generate different solutions. The key point of the assignment is help you learn fixed-point design, and understand the precision vs. cost vs. performance trade-off. 

\section{Acknowledgement}
This document is adapted from a project description originally developed by Prof. Ryan Kastner for CSE 237C at UCSD. 

\begin{thebibliography}{9}

\bibitem{cordic}
  P. Schaumont,
  \emph{A Practical Introduction to Hardware/Software Codesign},
  Springer,
  2013.

\bibitem{guide}
  Xilinx Inc., \emph{Vivado Design Suite User Guide: High-Level Synthesis UG902 (v2017.1)},
  Available at http://www.xilinx.com/support/documentation/sw\_manuals/xilinx2017\_1/ug902-vivado-high-level-synthesis.pdf
 


\end{thebibliography}

\end{document}